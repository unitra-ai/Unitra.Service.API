# Deploy to Production
# Triggered when a release is published (requires manual approval)
name: Deploy to Production

on:
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ============================================
  # Pre-deployment validation
  # ============================================
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Extract version
        id: version
        run: |
          VERSION="${{ github.event.release.tag_name }}"
          echo "version=${VERSION#v}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION}"

      - name: Validate tag format
        run: |
          TAG="${{ github.event.release.tag_name }}"
          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "Invalid tag format: $TAG"
            echo "Expected format: v1.2.3 or v1.2.3-beta"
            exit 1
          fi

  # ============================================
  # Build and push production image
  # ============================================
  build:
    name: Build Production Image
    runs-on: ubuntu-latest
    needs: validate
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.release.tag_name }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            GIT_COMMIT_SHA=${{ github.sha }}

  # ============================================
  # Deploy to production (requires approval)
  # ============================================
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, build]
    environment: production  # Requires manual approval in GitHub settings

    steps:
      - uses: actions/checkout@v4

      # ============================================
      # Option A: Deploy to Railway
      # ============================================
      - name: Deploy to Railway
        if: ${{ vars.DEPLOY_TARGET == 'railway' }}
        uses: bervProject/railway-deploy@main
        with:
          railway_token: ${{ secrets.RAILWAY_TOKEN }}
          service: unitra-api-production

      # ============================================
      # Option B: Deploy to Fly.io
      # ============================================
      - name: Setup Fly.io CLI
        if: ${{ vars.DEPLOY_TARGET == 'flyio' }}
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Deploy to Fly.io
        if: ${{ vars.DEPLOY_TARGET == 'flyio' }}
        run: flyctl deploy --remote-only --app unitra-api-production --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.release.tag_name }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      # ============================================
      # Option C: Deploy to Render
      # ============================================
      - name: Deploy to Render
        if: ${{ vars.DEPLOY_TARGET == 'render' }}
        run: |
          curl -X POST "${{ secrets.RENDER_DEPLOY_HOOK_URL }}"

      # ============================================
      # Run database migrations
      # ============================================
      - name: Run database migrations
        run: |
          echo "Running Alembic migrations..."
          # This would typically be done via a migration job or init container
          # alembic upgrade head
        continue-on-error: true

      # ============================================
      # Post-deployment validation
      # ============================================
      - name: Wait for deployment
        run: sleep 90

      - name: Health check
        run: |
          HEALTH_URL="${{ vars.PRODUCTION_API_URL }}/api/health"
          echo "Checking health at: $HEALTH_URL"

          for i in {1..10}; do
            RESPONSE=$(curl -sf "$HEALTH_URL" || echo "failed")
            if [ "$RESPONSE" != "failed" ]; then
              echo "Health check passed!"
              echo "$RESPONSE" | jq .
              exit 0
            fi
            echo "Attempt $i failed, retrying in 15s..."
            sleep 15
          done

          echo "Health check failed after 10 attempts"
          exit 1

      - name: Verify version
        run: |
          VERSION_URL="${{ vars.PRODUCTION_API_URL }}/api/version"
          DEPLOYED_VERSION=$(curl -sf "$VERSION_URL" | jq -r '.version')
          EXPECTED_VERSION="${{ needs.validate.outputs.version }}"

          echo "Deployed version: $DEPLOYED_VERSION"
          echo "Expected version: $EXPECTED_VERSION"

          if [ "$DEPLOYED_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "Version mismatch!"
            exit 1
          fi
        continue-on-error: true

  # ============================================
  # Notifications
  # ============================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always()

    steps:
      - name: Notify success
        if: needs.deploy.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            :rocket: *Production Deployment Successful!*
            Version: `${{ github.event.release.tag_name }}`
            Release: ${{ github.event.release.html_url }}
          fields: repo,author,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        continue-on-error: true

      - name: Notify failure
        if: needs.deploy.result == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            :x: *Production Deployment Failed!*
            Version: `${{ github.event.release.tag_name }}`
            Check the workflow for details.
          fields: repo,author,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        continue-on-error: true

      - name: Create deployment record
        if: needs.deploy.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: 'success',
              environment_url: '${{ vars.PRODUCTION_API_URL }}',
              description: 'Deployed ${{ github.event.release.tag_name }}'
            }).catch(() => {
              console.log('Could not create deployment status');
            });
        continue-on-error: true
